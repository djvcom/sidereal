//! Function discovery from compiled binaries.
//!
//! Discovers functions registered with the sidereal SDK by:
//! 1. Reading a `functions.json` manifest (if generated by SDK)
//! 2. Parsing Cargo.toml for binary targets as fallback

use std::path::Path;

use tracing::{debug, info, warn};

use crate::error::{BuildError, BuildResult};
use crate::types::FunctionMetadata;

/// Manifest file name for discovered functions.
const FUNCTIONS_MANIFEST: &str = "functions.json";

/// Discover functions from build output.
///
/// Looks for a functions.json manifest in the build output directory.
/// If not found, returns an empty list (functions will be discovered at runtime).
pub fn discover_functions(build_output_dir: &Path) -> BuildResult<Vec<FunctionMetadata>> {
    let manifest_path = build_output_dir.join(FUNCTIONS_MANIFEST);

    if manifest_path.exists() {
        info!(path = %manifest_path.display(), "reading functions manifest");
        read_manifest(&manifest_path)
    } else {
        debug!(
            path = %manifest_path.display(),
            "no functions manifest found, functions will be discovered at runtime"
        );
        Ok(Vec::new())
    }
}

/// Discover functions from the source directory.
///
/// Parses the project's sidereal.toml and Cargo.toml to infer function information.
/// This is a fallback when no manifest is available.
pub fn discover_from_source(source_dir: &Path) -> BuildResult<Vec<FunctionMetadata>> {
    let cargo_toml = source_dir.join("Cargo.toml");

    if !cargo_toml.exists() {
        return Ok(Vec::new());
    }

    let content = std::fs::read_to_string(&cargo_toml)?;
    let manifest: toml::Value = toml::from_str(&content)
        .map_err(|e| BuildError::ConfigParse(format!("failed to parse Cargo.toml: {e}")))?;

    let mut functions = Vec::new();

    // Check for [[bin]] targets
    if let Some(bins) = manifest.get("bin").and_then(|b| b.as_array()) {
        for bin in bins {
            if let Some(name) = bin.get("name").and_then(|n| n.as_str()) {
                functions.push(FunctionMetadata {
                    name: name.to_owned(),
                    route: None,
                    method: None,
                    queue: None,
                });
            }
        }
    }

    // If no bins, check package name as the default binary
    if functions.is_empty() {
        if let Some(name) = manifest
            .get("package")
            .and_then(|p| p.get("name"))
            .and_then(|n| n.as_str())
        {
            functions.push(FunctionMetadata {
                name: name.to_owned(),
                route: None,
                method: None,
                queue: None,
            });
        }
    }

    debug!(
        count = functions.len(),
        "discovered functions from Cargo.toml"
    );
    Ok(functions)
}

/// Read functions from a manifest file.
fn read_manifest(path: &Path) -> BuildResult<Vec<FunctionMetadata>> {
    let content = std::fs::read_to_string(path)?;
    let functions: Vec<FunctionMetadata> = serde_json::from_str(&content)
        .map_err(|e| BuildError::ConfigParse(format!("failed to parse functions manifest: {e}")))?;

    info!(count = functions.len(), "loaded functions from manifest");
    Ok(functions)
}

/// Write functions to a manifest file.
pub fn write_manifest(path: &Path, functions: &[FunctionMetadata]) -> BuildResult<()> {
    let content = serde_json::to_string_pretty(functions)
        .map_err(|e| BuildError::Internal(format!("failed to serialise functions: {e}")))?;

    std::fs::write(path, content)?;
    info!(path = %path.display(), count = functions.len(), "wrote functions manifest");
    Ok(())
}

/// Validate discovered functions against configuration.
pub fn validate_functions(
    functions: &[FunctionMetadata],
    config: &crate::config::SiderealConfig,
) -> BuildResult<()> {
    // Check that queue functions reference declared queues
    let declared_queues = crate::get_declared_queues(config);

    for func in functions {
        if let Some(queue_name) = &func.queue {
            if !declared_queues.contains(&queue_name.as_str()) {
                warn!(
                    function = %func.name,
                    queue = %queue_name,
                    "function references undeclared queue"
                );
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn discover_from_manifest() {
        let dir = TempDir::new().unwrap();
        let manifest_path = dir.path().join(FUNCTIONS_MANIFEST);

        let functions = vec![
            FunctionMetadata {
                name: "handle_order".to_owned(),
                route: Some("/orders".to_owned()),
                method: Some("POST".to_owned()),
                queue: None,
            },
            FunctionMetadata {
                name: "process_payment".to_owned(),
                route: None,
                method: None,
                queue: Some("payments".to_owned()),
            },
        ];

        let content = serde_json::to_string(&functions).unwrap();
        std::fs::write(&manifest_path, content).unwrap();

        let discovered = discover_functions(dir.path()).unwrap();
        assert_eq!(discovered.len(), 2);
        assert_eq!(discovered[0].name, "handle_order");
        assert_eq!(discovered[1].name, "process_payment");
    }

    #[test]
    fn discover_without_manifest() {
        let dir = TempDir::new().unwrap();
        let discovered = discover_functions(dir.path()).unwrap();
        assert!(discovered.is_empty());
    }

    #[test]
    fn discover_from_cargo_toml() {
        let dir = TempDir::new().unwrap();
        let cargo_toml = dir.path().join("Cargo.toml");

        let content = r#"
            [package]
            name = "my-service"
            version = "0.1.0"

            [[bin]]
            name = "api-handler"

            [[bin]]
            name = "queue-worker"
        "#;

        std::fs::write(&cargo_toml, content).unwrap();

        let functions = discover_from_source(dir.path()).unwrap();
        assert_eq!(functions.len(), 2);
        assert_eq!(functions[0].name, "api-handler");
        assert_eq!(functions[1].name, "queue-worker");
    }

    #[test]
    fn discover_from_cargo_toml_no_bins() {
        let dir = TempDir::new().unwrap();
        let cargo_toml = dir.path().join("Cargo.toml");

        let content = r#"
            [package]
            name = "simple-service"
            version = "0.1.0"
        "#;

        std::fs::write(&cargo_toml, content).unwrap();

        let functions = discover_from_source(dir.path()).unwrap();
        assert_eq!(functions.len(), 1);
        assert_eq!(functions[0].name, "simple-service");
    }

    #[test]
    fn write_and_read_manifest() {
        let dir = TempDir::new().unwrap();
        let manifest_path = dir.path().join(FUNCTIONS_MANIFEST);

        let functions = vec![FunctionMetadata {
            name: "test_func".to_owned(),
            route: Some("/test".to_owned()),
            method: Some("GET".to_owned()),
            queue: None,
        }];

        write_manifest(&manifest_path, &functions).unwrap();

        let loaded = read_manifest(&manifest_path).unwrap();
        assert_eq!(loaded.len(), 1);
        assert_eq!(loaded[0].name, "test_func");
    }
}
